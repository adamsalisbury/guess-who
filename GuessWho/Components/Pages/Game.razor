@page "/game/{Code}"
@rendermode InteractiveServer
@implements IDisposable
@inject GameSessionService GameSessionService
@inject NavigationManager Nav
@inject IJSRuntime JS
@using GuessWho.Data
@using GuessWho.Models

<PageTitle>@Code | Guess Who?</PageTitle>

@* â”€â”€ Session / participant guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
@if (_session is null)
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>Session not found. <a href="/">Return home</a></p>
        </div>
    </div>
}
else if (_me is null)
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>You are not part of this session. <a href="/">Return home</a></p>
        </div>
    </div>
}

@* â”€â”€ CharacterSelection: picker (Challenge Mode: pick TWO) â”€â”€â”€â”€ *@
else if (_session.Phase == GamePhase.CharacterSelection && !_me.HasSelectedMysteryPeople)
{
    <div class="selection-page">

        <div class="selection-header">
            <h1 class="selection-title">Choose Your Two Mystery People</h1>
            <p class="selection-subtitle">
                Pick <strong>two</strong> characters â€” your opponent must identify both.
                Your choices are secret from <strong>@(_opponent?.Name ?? "your opponent")</strong>.
            </p>
        </div>

        <div class="selection-grid-area">
            <div class="selection-grid">
                @foreach (var character in CharacterData.All)
                {
                    var charId = character.Id;
                    var isChosen = _pendingIds.Contains(charId);
                    var isDimmed = !isChosen && _pendingIds.Count == 2;
                    <div class="selection-card-wrap @(isDimmed ? "selection-card-wrap--dimmed" : "")">
                        <FaceCard Character="character"
                                  Size="md"
                                  ShowName="true"
                                  IsMystery="@isChosen"
                                  OnClick="@(_ => TogglePending(charId))" />
                    </div>
                }
            </div>
        </div>

        <div class="selection-footer">
            @if (_pendingIds.Count == 0)
            {
                <p class="selection-hint">Click two characters to select your Mystery People (0 / 2 chosen)</p>
            }
            else if (_pendingIds.Count == 1)
            {
                var chosen1 = CharacterData.GetById(_pendingIds[0])!;
                <div class="selection-chosen-pair">
                    <div class="selection-chosen-slot selection-chosen-slot--filled">
                        <FaceCard Character="chosen1" Size="sm" IsMystery="true" ShowName="false" />
                        <span class="selection-chosen-name">@chosen1.Name</span>
                    </div>
                    <div class="selection-chosen-slot selection-chosen-slot--empty">
                        <div class="selection-chosen-placeholder">?</div>
                        <span class="selection-chosen-name selection-chosen-name--muted">Choose one moreâ€¦</span>
                    </div>
                </div>
                <p class="selection-hint selection-hint--progress">1 of 2 chosen â€” pick one more</p>
                <button class="btn btn-secondary" @onclick="ClearPending">Clear</button>
            }
            else
            {
                var chosen1 = CharacterData.GetById(_pendingIds[0])!;
                var chosen2 = CharacterData.GetById(_pendingIds[1])!;
                <div class="selection-chosen-pair">
                    <div class="selection-chosen-slot selection-chosen-slot--filled">
                        <FaceCard Character="chosen1" Size="sm" IsMystery="true" ShowName="false" />
                        <span class="selection-chosen-name">@chosen1.Name</span>
                    </div>
                    <div class="selection-chosen-slot selection-chosen-slot--filled">
                        <FaceCard Character="chosen2" Size="sm" IsMystery="true" ShowName="false" />
                        <span class="selection-chosen-name">@chosen2.Name</span>
                    </div>
                </div>
                <button class="btn btn-primary selection-confirm-btn" @onclick="ConfirmSelection">
                    Confirm â€” @chosen1.Name &amp; @chosen2.Name
                </button>
                <button class="btn btn-secondary" @onclick="ClearPending">Change</button>
            }
        </div>

    </div>
}

@* â”€â”€ CharacterSelection: waiting for opponent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
else if (_session.Phase == GamePhase.CharacterSelection && _me.HasSelectedMysteryPeople)
{
    var mp1 = CharacterData.GetById(_me.MysteryPersonIds[0]);
    var mp2 = CharacterData.GetById(_me.MysteryPersonIds[1]);
    <div class="waiting-page">
        <div class="waiting-card">
            <div class="waiting-mystery waiting-mystery--pair">
                <FaceCard Character="mp1" Size="sm" IsMystery="true" ShowName="true" />
                <FaceCard Character="mp2" Size="sm" IsMystery="true" ShowName="true" />
            </div>
            <h2 class="waiting-title">Locked In!</h2>
            <p class="waiting-subtitle">
                Your Mystery People are
                <strong class="waiting-highlight">@mp1?.Name</strong> and
                <strong class="waiting-highlight">@mp2?.Name</strong>.
            </p>
            <p class="waiting-subtitle">
                Waiting for <strong>@(_opponent?.Name ?? "your opponent")</strong> to chooseâ€¦
            </p>
            <div class="spinner waiting-spinner"></div>
        </div>
    </div>
}

@* â”€â”€ Playing / RoundEnd phase â€” full game board (+ overlay) â”€â”€ *@
else if (_session.Phase is GamePhase.Playing or GamePhase.RoundEnd)
{
    var myPeople = _me!.MysteryPersonIds
        .Select(id => CharacterData.GetById(id))
        .Where(c => c is not null)
        .ToList();

    <div class="game-board">

        @* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LEFT COLUMN â€” opponent board (top) + own board (bottom)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *@
        <div class="game-left">

            @* â”€â”€ Opponent's board (top, sm cards) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            @* In guess mode the active player can click face-up cards to build their guess *@
            <div class="board-section">
                <div class="board-header">
                    <span class="board-label">
                        @(_opponent?.Name ?? "Opponent")'s Board
                        @if (_guessModeActive)
                        {
                            <span style="color:var(--accent-blue);margin-left:6px;font-size:0.68rem;">
                                â€” GUESS MODE (@_pendingGuessIds.Count/2 selected)
                            </span>
                        }
                    </span>
                    <span class="board-count">
                        @if (_opponent?.EliminatedIds.Count > 0)
                        {
                            @($"{_opponent.EliminatedIds.Count} eliminated")
                        }
                        else
                        {
                            @("24 remaining")
                        }
                    </span>
                </div>
                <div class="board-grid-area">
                    <div class="board-grid board-grid--sm">
                        @foreach (var charId in _opponent?.BoardOrder ?? [])
                        {
                            var localId = charId;
                            var ch = CharacterData.GetById(localId);
                            var isOppEliminated = _opponent!.EliminatedIds.Contains(localId);
                            var isSelectedForGuess = _guessModeActive && _pendingGuessIds.Contains(localId);
                            // Guessable: guess mode active, my turn, face-up, not already selected, still room to pick
                            var canGuess = _guessModeActive && _isMyTurn && !isOppEliminated
                                           && !isSelectedForGuess && _pendingGuessIds.Count < 2;
                            <FaceCard Character="ch"
                                      Size="sm"
                                      ShowName="true"
                                      FaceDown="@isOppEliminated"
                                      IsSelected="@isSelectedForGuess"
                                      IsGuessable="@canGuess"
                                      OnClick="@GetGuessCallback(localId, isOppEliminated, isSelectedForGuess, canGuess)" />
                        }
                    </div>
                </div>
            </div>

            <div class="board-divider"></div>

            @* â”€â”€ Own board (bottom, md cards) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            <div class="board-section board-section--own">
                <div class="board-header">
                    <span class="board-label">@_me!.Name's Board</span>
                    <span class="board-count">
                        @(_me!.EliminatedIds.Count == 0
                            ? "24 remaining"
                            : $"{_me!.BoardOrder.Count - _me!.EliminatedIds.Count} remaining Â· {_me!.EliminatedIds.Count} eliminated")
                    </span>
                </div>
                <div class="board-grid-area">
                    <div class="board-grid board-grid--md">
                        @foreach (var charId in _me!.BoardOrder)
                        {
                            var localId = charId;
                            var ch = CharacterData.GetById(localId);
                            var isMystery = _me!.MysteryPersonIds.Contains(localId);
                            var isEliminated = _me!.EliminatedIds.Contains(localId);
                            var canEliminate = _isMyTurn && !isMystery && !isEliminated;
                            <FaceCard Character="ch"
                                      Size="md"
                                      ShowName="true"
                                      IsMystery="@isMystery"
                                      FaceDown="@isEliminated"
                                      IsEliminatable="@canEliminate"
                                      OnClick="@GetEliminateCallback(localId, canEliminate)" />
                        }
                    </div>
                </div>
            </div>

        </div>

        @* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RIGHT COLUMN â€” score bar, mystery people, chat panel
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *@
        <div class="game-right">

            @* â”€â”€ Score & status bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            <div class="score-bar">
                <div class="score-round">Round @_session.RoundNumber</div>
                <div class="score-display">
                    <span class="score-name">@_session.Player1?.Name</span>
                    <span class="score-value">@_session.Player1?.RoundWins</span>
                    <span class="score-dash">â€“</span>
                    <span class="score-value">@_session.Player2?.RoundWins</span>
                    <span class="score-name score-name--right">@_session.Player2?.Name</span>
                </div>
                <div class="turn-status @(_isMyTurn ? "turn-status--active" : "turn-status--waiting")">
                    @if (_isMyTurn)
                    {
                        <span class="turn-indicator-dot"></span>
                        <span>Your turn, @(_me?.Name ?? "you")</span>
                    }
                    else
                    {
                        <span>Waiting for @(_opponent?.Name ?? "opponent")â€¦</span>
                    }
                </div>
                @if (_session.CountdownActive)
                {
                    <div class="countdown-bar">
                        <span class="countdown-icon">â±</span>
                        <span class="countdown-text">Turn ending in <strong>@CountdownRemaining</strong>sâ€¦</span>
                    </div>
                }
            </div>

            @* â”€â”€ Mystery People display (two cards side by side) â”€â”€â”€ *@
            <div class="mystery-panel">
                <div class="mystery-label">Your Mystery People</div>
                <div class="mystery-cards-row">
                    @foreach (var mp in myPeople)
                    {
                        <div class="mystery-card-wrap">
                            <FaceCard Character="mp" Size="sm" IsMystery="true" ShowName="true" />
                        </div>
                    }
                </div>
                <div class="mystery-keep-secret">Keep these secret from your opponent!</div>
            </div>

            @* â”€â”€ Chat panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            <div class="chat-panel">
                <div class="chat-header">Chat</div>

                @* â”€â”€ Message log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                <div class="chat-log" @ref="_chatLogRef"
                     role="log" aria-live="polite" aria-label="Game chat log">
                    @if (_session!.ChatLog.Count == 0)
                    {
                        <p class="chat-placeholder">The game is afootâ€¦</p>
                    }
                    else
                    {
                        @foreach (var entry in GetChatEntries())
                        {
                            var msg   = entry.Message;
                            var turnQ = entry.TurnNumber;

                            @* Insert a labelled divider before every question after the first *@
                            @if (msg.Kind == ChatMessageKind.Question && turnQ > 1)
                            {
                                <div class="chat-turn-divider">
                                    <span class="chat-turn-label">Turn @turnQ</span>
                                </div>
                            }

                            <div class="chat-msg chat-msg--@msg.Kind.ToString().ToLowerInvariant()">
                                @if (msg.Kind == ChatMessageKind.Question)
                                {
                                    @* Sender name (left) + compact turn tag (right) *@
                                    <div class="chat-msg-header">
                                        <span class="chat-msg-sender">@msg.SenderName</span>
                                        <span class="chat-msg-turn-tag">T@turnQ</span>
                                    </div>
                                    <span class="chat-msg-text">@msg.Text</span>
                                }
                                else if (msg.Kind == ChatMessageKind.Answer)
                                {
                                    @* Large answer text (Both / One of them / Neither) â€” easy to scan *@
                                    <span class="chat-msg-answer-text">@msg.Text</span>
                                    <span class="chat-msg-sender">@msg.SenderName</span>
                                }
                                else
                                {
                                    @* System event â€” just the text, no sender label *@
                                    <span class="chat-msg-text">@msg.Text</span>
                                }
                            </div>
                        }
                    }
                </div>

                @* â”€â”€ Input area â€” branches on turn state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                <div class="chat-input-area">

                    @* End Turn always available to active player (even in guess mode) *@
                    @if (_isMyTurn)
                    {
                        <button class="btn btn-secondary end-turn-btn" @onclick="EndTurn">
                            End Turn
                        </button>
                    }

                    @* â”€â”€ Active player: no question asked yet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                    @if (_isMyTurn && !_session.QuestionAsked)
                    {
                        @if (_guessModeActive)
                        {
                            @* Guess mode active â€” show pick status or confirmation *@
                            @if (_pendingGuessIds.Count == 2)
                            {
                                @* Two cards selected â€” show confirmation panel *@
                                var g1 = CharacterData.GetById(_pendingGuessIds[0]);
                                var g2 = CharacterData.GetById(_pendingGuessIds[1]);
                                <div class="guess-confirm-panel">
                                    <div class="guess-confirm-names">
                                        <span class="guess-confirm-name">@g1?.Name</span>
                                        <span class="guess-confirm-and">&amp;</span>
                                        <span class="guess-confirm-name">@g2?.Name</span>
                                    </div>
                                    <div class="guess-confirm-warning">
                                        Guess these two people? A wrong guess means you lose immediately.
                                    </div>
                                    <div class="guess-confirm-buttons">
                                        <button class="btn-guess-confirm" @onclick="ConfirmGuess">Confirm Guess</button>
                                        <button class="btn-guess-cancel" @onclick="CancelGuessMode">Cancel</button>
                                    </div>
                                </div>
                            }
                            else if (_pendingGuessIds.Count == 1)
                            {
                                @* One card selected â€” show partial hint *@
                                var g1 = CharacterData.GetById(_pendingGuessIds[0]);
                                <div class="guess-mode-active">
                                    <p class="guess-mode-hint">
                                        ğŸ¯ <strong>@g1?.Name</strong> selected â€” click one more face to complete your guess
                                    </p>
                                    <button class="btn-guess-cancel" @onclick="CancelGuessMode">Cancel Guess Mode</button>
                                </div>
                            }
                            else
                            {
                                @* No cards selected yet â€” show initial instruction *@
                                <div class="guess-mode-active">
                                    <p class="guess-mode-hint">ğŸ¯ Click two faces on the opponent's board to guess</p>
                                    <button class="btn-guess-cancel" @onclick="CancelGuessMode">Cancel Guess Mode</button>
                                </div>
                            }
                        }
                        else
                        {
                            @* Normal state â€” question input + suggestions + Make a Guess button *@
                            <div class="chat-input-row">
                                <input class="text-input chat-input"
                                       type="text"
                                       placeholder="Ask a yes/no questionâ€¦"
                                       @bind="_chatInput"
                                       @bind:event="oninput"
                                       @onkeydown="OnChatKeyDown"
                                       maxlength="200" />
                                <button class="btn btn-primary chat-send-btn"
                                        disabled="@(string.IsNullOrWhiteSpace(_chatInput))"
                                        @onclick="SendQuestion">
                                    Send
                                </button>
                            </div>

                            @* â”€â”€ Suggested questions toggle + chip panel â”€â”€â”€â”€â”€â”€ *@
                            <button class="suggestions-toggle @(_suggestionsOpen ? "suggestions-toggle--open" : "")"
                                    @onclick="ToggleSuggestions"
                                    title="@(_suggestionsOpen ? "Hide suggested questions" : "Show suggested questions")">
                                <span class="suggestions-toggle-icon">ğŸ’¡</span>
                                <span>Suggest a question</span>
                                <span class="suggestions-toggle-arrow">@(_suggestionsOpen ? "â–²" : "â–¼")</span>
                            </button>

                            @if (_suggestionsOpen)
                            {
                                <div class="suggestions-panel">
                                    @foreach (var q in SuggestedQuestions)
                                    {
                                        var localQ = q;
                                        <button class="question-chip" @onclick="@(() => SelectSuggestedQuestion(localQ))">
                                            @localQ
                                        </button>
                                    }
                                </div>
                            }

                            <button class="guess-mode-btn" @onclick="ActivateGuessMode">
                                ğŸ¯ Make a Guess Instead
                            </button>
                        }
                    }

                    @* â”€â”€ Active player: question already asked â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                    else if (_isMyTurn && _session.QuestionAsked)
                    {
                        @if (_session.AwaitingAnswer)
                        {
                            <p class="chat-awaiting">Waiting for @(_opponent?.Name ?? "opponent") to answerâ€¦</p>
                        }
                        else if (_session.CountdownActive)
                        {
                            <p class="chat-awaiting">
                                Turn ends in <strong class="countdown-inline">@CountdownRemaining</strong>s â€” or end it now.
                            </p>
                        }
                        else
                        {
                            <p class="chat-awaiting">Question answered â€” end your turn when ready.</p>
                        }
                    }

                    @* â”€â”€ Inactive player: question awaiting answer â”€â”€â”€â”€â”€â”€ *@
                    @* Challenge Mode: three answer options â€” Both, One of them, Neither *@
                    else if (!_isMyTurn && _session.AwaitingAnswer)
                    {
                        <div class="chat-yn-row">
                            <p class="chat-yn-prompt">Answer @(_session.GetPlayer(_session.ActivePlayerToken)?.Name ?? "opponent")'s question about your two people:</p>
                            <div class="chat-triple-buttons">
                                <button class="btn btn-both"    @onclick="@(() => RespondToQuestion("Both"))">Both</button>
                                <button class="btn btn-one"     @onclick="@(() => RespondToQuestion("One of them"))">One of them</button>
                                <button class="btn btn-neither" @onclick="@(() => RespondToQuestion("Neither"))">Neither</button>
                            </div>
                        </div>
                    }

                    @* â”€â”€ Inactive player: nothing to do â€” locked â”€â”€â”€â”€â”€â”€â”€â”€ *@
                    else
                    {
                        <div class="chat-input-row">
                            <input class="text-input chat-input"
                                   type="text"
                                   placeholder="Waiting for your turnâ€¦"
                                   disabled="true" />
                            <button class="btn btn-primary chat-send-btn" disabled="true">Send</button>
                        </div>
                    }

                </div>
            </div>

        </div>
    </div>

    @* â”€â”€ Round-End Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
    @* Rendered on top of the board when the phase is RoundEnd.  *@
    @if (_session.Phase == GamePhase.RoundEnd)
    {
        var isWinner   = _session.RoundWinnerToken == MyToken;
        var winnerName = _session.GetPlayer(_session.RoundWinnerToken ?? "")?.Name ?? "Unknown";
        var loserName  = _session.GetOpponent(_session.RoundWinnerToken ?? "")?.Name ?? "Unknown";

        // Match champion data
        var matchWinnerName = _session.IsMatchOver
            ? (_session.GetPlayer(_session.MatchWinnerToken ?? "")?.Name ?? "Unknown")
            : null;
        var iAmMatchWinner = _session.MatchWinnerToken == MyToken;

        // Button label changes to "Play Again" when a match has just been won
        var continueLabel = _session.IsMatchOver ? "Play Again" : "New Round";

        // Per-player post-round decisions from the server
        var myDecision  = MyToken is not null ? _session.GetPostRoundDecision(MyToken) : null;
        var oppDecision = _opponent?.Token is not null ? _session.GetPostRoundDecision(_opponent.Token) : null;

        <div class="round-end-overlay">
            <div class="round-end-card">

                @* â”€â”€ Match champion banner (only when a player has won 5 rounds) â”€â”€ *@
                @if (_session.IsMatchOver)
                {
                    <div class="round-end-match-banner @(iAmMatchWinner ? "round-end-match-banner--win" : "round-end-match-banner--loss")">
                        @if (iAmMatchWinner)
                        {
                            @("ğŸ† You win the match!")
                        }
                        else
                        {
                            @($"ğŸ† {matchWinnerName} wins the match!")
                        }
                    </div>
                }

                @* â”€â”€ Round outcome heading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                <div class="round-end-outcome @(isWinner ? "round-end-outcome--win" : "round-end-outcome--loss")">
                    @(isWinner ? "You win the round! ğŸ‰" : "You lose the round")
                </div>

                @* â”€â”€ Explanation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                <p class="round-end-subtext">
                    @if (_session.EndReason == RoundEndReason.CorrectGuess)
                    {
                        @($"{winnerName} identified both Mystery People correctly!")
                    }
                    else
                    {
                        @($"{loserName} guessed wrong â€” {winnerName} wins the round!")
                    }
                </p>

                <div class="round-end-divider"></div>

                @* â”€â”€ Mystery People reveal â€” 2 cards per player (4 total) â”€â”€ *@
                <div class="round-end-reveal">
                    @* Player 1's two Mystery People *@
                    <div class="round-end-reveal-player">
                        <div class="round-end-reveal-player-label">@(_session.Player1?.Name)'s People</div>
                        <div class="round-end-reveal-cards">
                            @foreach (var mpId in _session.Player1?.MysteryPersonIds ?? [])
                            {
                                var mp = CharacterData.GetById(mpId);
                                @if (mp is not null)
                                {
                                    <div class="round-end-reveal-slot">
                                        <FaceCard Character="mp" Size="sm" ShowName="false" IsMystery="true" />
                                        <div class="round-end-reveal-name">@mp.Name</div>
                                    </div>
                                }
                            }
                        </div>
                    </div>

                    @* Player 2's two Mystery People *@
                    <div class="round-end-reveal-player">
                        <div class="round-end-reveal-player-label">@(_session.Player2?.Name)'s People</div>
                        <div class="round-end-reveal-cards">
                            @foreach (var mpId in _session.Player2?.MysteryPersonIds ?? [])
                            {
                                var mp = CharacterData.GetById(mpId);
                                @if (mp is not null)
                                {
                                    <div class="round-end-reveal-slot">
                                        <FaceCard Character="mp" Size="sm" ShowName="false" IsMystery="true" />
                                        <div class="round-end-reveal-name">@mp.Name</div>
                                    </div>
                                }
                            }
                        </div>
                    </div>
                </div>

                <div class="round-end-divider"></div>

                @* â”€â”€ Championship score â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                <div class="round-end-score">
                    <span class="round-end-score-name">@_session.Player1?.Name</span>
                    <span class="round-end-score-value">@_session.Player1?.RoundWins</span>
                    <span class="round-end-score-dash">â€“</span>
                    <span class="round-end-score-value">@_session.Player2?.RoundWins</span>
                    <span class="round-end-score-name round-end-score-name--right">@_session.Player2?.Name</span>
                </div>

                @* â”€â”€ Decision status chips â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                @* Shown once at least one player has clicked a button.      *@
                @if (myDecision.HasValue || oppDecision.HasValue)
                {
                    <div class="round-end-decisions">
                        <div class="decision-chip @(myDecision.HasValue ? "decision-chip--chosen" : "")">
                            <span class="decision-chip-name">@(_me?.Name ?? "You")</span>
                            <span class="decision-chip-choice">
                                @(myDecision.HasValue
                                    ? (myDecision == PostRoundDecision.NewRound ? continueLabel : "End Game")
                                    : "â€”")
                            </span>
                        </div>
                        <div class="decision-chip @(oppDecision.HasValue ? "decision-chip--chosen" : "")">
                            <span class="decision-chip-name">@(_opponent?.Name ?? "Opponent")</span>
                            <span class="decision-chip-choice">
                                @(oppDecision.HasValue
                                    ? (oppDecision == PostRoundDecision.NewRound ? continueLabel : "End Game")
                                    : "â€”")
                            </span>
                        </div>
                    </div>

                    @* Status message when waiting for consensus *@
                    @if (myDecision.HasValue && !oppDecision.HasValue)
                    {
                        <p class="round-end-waiting">Waiting for @(_opponent?.Name ?? "opponent") to decideâ€¦</p>
                    }
                    else if (myDecision.HasValue && oppDecision.HasValue && myDecision != oppDecision)
                    {
                        <p class="round-end-waiting">
                            Waiting to agreeâ€¦ game ends automatically in 60s if unresolved.
                        </p>
                    }
                }

                @* â”€â”€ Action buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                @* Disabled once this player has clicked â€” no changing your mind. *@
                <div class="round-end-actions">
                    <button class="btn btn-primary @(myDecision == PostRoundDecision.NewRound ? "btn--chosen" : "")"
                            disabled="@myDecision.HasValue"
                            @onclick="@(() => MakeDecision(PostRoundDecision.NewRound))">
                        @continueLabel
                    </button>
                    <button class="btn btn-secondary @(myDecision == PostRoundDecision.EndGame ? "btn--chosen" : "")"
                            disabled="@myDecision.HasValue"
                            @onclick="@(() => MakeDecision(PostRoundDecision.EndGame))">
                        End Game
                    </button>
                </div>

            </div>
        </div>
    }
}

@* â”€â”€ Fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
else
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>Session ended or unavailable. <a href="/">Return home</a></p>
        </div>
    </div>
}

@code {
    [Parameter] public string Code { get; set; } = "";
    [SupplyParameterFromQuery(Name = "name")] public string? PlayerName { get; set; }
    [SupplyParameterFromQuery(Name = "token")] public string? MyToken { get; set; }

    private GameSession? _session;
    private PlayerState? _me;
    private PlayerState? _opponent;

    /// <summary>
    /// Characters selected during the CharacterSelection phase (Challenge Mode: up to 2).
    /// Clicking a card adds it; clicking again removes it; list capped at 2 entries.
    /// </summary>
    private readonly List<int> _pendingIds = [];

    /// <summary>True when the active player has activated guess mode on the opponent's board.</summary>
    private bool _guessModeActive;

    /// <summary>
    /// Characters selected for the pending guess (Challenge Mode: up to 2).
    /// Clicking a card in guess mode adds it; clicking again deselects it.
    /// </summary>
    private readonly List<int> _pendingGuessIds = [];

    /// <summary>Current value of the chat text input.</summary>
    private string _chatInput = "";

    /// <summary>Whether the suggested-questions chip panel is expanded.</summary>
    private bool _suggestionsOpen;

    /// <summary>
    /// Canned yes/no questions covering every attribute in the character set.
    /// Displayed as one-click chips that populate the chat input.
    /// </summary>
    private static readonly string[] SuggestedQuestions =
    [
        "Does your person wear glasses?",
        "Does your person have a hat?",
        "Does your person have facial hair?",
        "Does your person have long hair?",
        "Is your person bald?",
        "Does your person have rosy cheeks?",
        "Does your person have a big nose?",
        "Does your person have blue eyes?",
        "Does your person have brown eyes?",
        "Does your person have blonde hair?",
        "Does your person have red hair?",
        "Does your person have white hair?",
        "Does your person have black hair?",
        "Does your person have brown hair?",
    ];

    /// <summary>Reference to the chat log div, used for auto-scroll.</summary>
    private ElementReference _chatLogRef;

    /// <summary>Timer that drives the post-answer countdown display and automatic turn-end.</summary>
    private System.Threading.Timer? _countdownTimer;

    /// <summary>Mirror of GameSession.CountdownSeconds â€” used for client-side remaining-time math.</summary>
    private const int CountdownSeconds = GameSession.CountdownSeconds;

    /// <summary>True when it is this player's turn to act.</summary>
    private bool _isMyTurn =>
        _session is not null && MyToken is not null && _session.IsActivePlayer(MyToken);

    /// <summary>
    /// Remaining whole seconds in the current countdown, clamped to [0, CountdownSeconds].
    /// Returns 0 when no countdown is active.
    /// </summary>
    private int CountdownRemaining =>
        _session?.CountdownActive == true
            ? (int)Math.Ceiling(Math.Max(0,
                CountdownSeconds - (DateTime.UtcNow - _session.CountdownStartedAt!.Value).TotalSeconds))
            : 0;

    protected override void OnInitialized()
    {
        _session = GameSessionService.GetSession(Code);
        if (_session is null) return;

        _me       = _session.GetPlayer(MyToken ?? "");
        _opponent = _session.GetOpponent(MyToken ?? "");

        _session.StateChanged += OnSessionStateChanged;
    }

    /// <summary>
    /// Invoked on a thread-pool thread when session state changes.
    /// Marshals the UI update back to this component's Blazor circuit thread.
    /// </summary>
    private async void OnSessionStateChanged(object? sender, EventArgs e)
    {
        await InvokeAsync(async () =>
        {
            _opponent = _session?.GetOpponent(MyToken ?? "");

            // Clear guess mode and suggestion panel when the turn passes or the round ends
            if (!_isMyTurn || _session?.Phase != GamePhase.Playing)
            {
                _guessModeActive = false;
                _pendingGuessIds.Clear();
                _suggestionsOpen = false;
            }

            StateHasChanged();

            // Navigate home immediately when the session enters GameEnd phase
            if (_session?.Phase == GamePhase.GameEnd)
            {
                Nav.NavigateTo("/");
                return;
            }

            // Start the countdown timer when the session enters the post-answer countdown window.
            if (_session?.CountdownActive == true)
                StartCountdownTimer();

            // Auto-scroll chat log when new messages arrive
            if (_session?.Phase is GamePhase.Playing or GamePhase.RoundEnd)
                await ScrollChatToBottom();
        });
    }

    /// <summary>
    /// Creates (or re-creates) a 500ms-interval timer that drives the countdown display and
    /// fires StartNextTurn when the countdown expires.
    /// Only the active player's circuit calls StartNextTurn; both circuits update the display.
    /// </summary>
    private void StartCountdownTimer()
    {
        _countdownTimer?.Dispose();
        _countdownTimer = new System.Threading.Timer(async _ =>
        {
            try
            {
                if (_session?.CountdownActive != true)
                {
                    _countdownTimer?.Dispose();
                    _countdownTimer = null;
                    await InvokeAsync(StateHasChanged);
                    return;
                }

                var elapsed = (DateTime.UtcNow - _session.CountdownStartedAt!.Value).TotalSeconds;

                // Only the active player fires StartNextTurn to avoid double-fire from both circuits
                if (elapsed >= CountdownSeconds && _isMyTurn)
                    GameSessionService.StartNextTurn(Code, MyToken!);

                await InvokeAsync(StateHasChanged);
            }
            catch (ObjectDisposedException) { /* Component disposed â€” stop silently */ }
            catch (Exception) { /* Swallow any other interop failures */ }
        }, null, dueTime: 0, period: 500);
    }

    /// <summary>
    /// Returns an EventCallback that calls EliminateCard when canEliminate is true,
    /// or an empty callback otherwise.
    /// </summary>
    private EventCallback<Character?> GetEliminateCallback(int characterId, bool canEliminate) =>
        canEliminate
            ? EventCallback.Factory.Create<Character?>(this, _ => EliminateCard(characterId))
            : default;

    /// <summary>
    /// Returns an EventCallback for an opponent board card in guess mode.
    /// - If already selected: clicking deselects it.
    /// - If can be added (face-up, &lt;2 pending): clicking selects it.
    /// - Otherwise: no callback.
    /// </summary>
    private EventCallback<Character?> GetGuessCallback(int characterId, bool isOppEliminated,
                                                        bool isSelected, bool canGuess)
    {
        if (!_guessModeActive || !_isMyTurn || isOppEliminated) return default;
        if (isSelected)
            return EventCallback.Factory.Create<Character?>(this, _ => DeselectGuess(characterId));
        if (canGuess)
            return EventCallback.Factory.Create<Character?>(this, _ => SelectForGuess(characterId));
        return default;
    }

    /// <summary>
    /// Eliminates a character from the active player's own board.
    /// Server-side guards prevent eliminating Mystery People or non-active-player requests.
    /// </summary>
    private void EliminateCard(int characterId)
    {
        if (!_isMyTurn || MyToken is null) return;
        GameSessionService.EliminateCharacter(Code, MyToken, characterId);
    }

    /// <summary>Passes the turn to the opposing player.</summary>
    private void EndTurn()
    {
        if (MyToken is not null)
            GameSessionService.StartNextTurn(Code, MyToken);
    }

    /// <summary>Sends the current chat input as a question. Called by the Send button or Enter key.</summary>
    private async Task SendQuestion()
    {
        if (!_isMyTurn || string.IsNullOrWhiteSpace(_chatInput)) return;
        GameSessionService.AskQuestion(Code, MyToken!, _chatInput.Trim());
        _chatInput = "";
        _suggestionsOpen = false;
        await ScrollChatToBottom();
    }

    /// <summary>Expands or collapses the suggested-questions chip panel.</summary>
    private void ToggleSuggestions() => _suggestionsOpen = !_suggestionsOpen;

    /// <summary>
    /// Populates the chat input with the selected suggested question and closes the chip panel.
    /// </summary>
    private void SelectSuggestedQuestion(string questionText)
    {
        _chatInput       = questionText;
        _suggestionsOpen = false;
    }

    /// <summary>Called when the inactive player clicks one of the three answer buttons.</summary>
    private async Task RespondToQuestion(string answer)
    {
        if (_isMyTurn || _session?.AwaitingAnswer != true) return;
        GameSessionService.AnswerQuestion(Code, MyToken!, answer);
        await ScrollChatToBottom();
    }

    /// <summary>Handles Enter-key press in the chat input to submit the question.</summary>
    private async Task OnChatKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await SendQuestion();
    }

    /// <summary>Scrolls the chat log to the bottom after a new message is added.</summary>
    private async Task ScrollChatToBottom()
    {
        try
        {
            await JS.InvokeVoidAsync("eval",
                "document.querySelector('.chat-log')?.scrollTo({top:999999,behavior:'smooth'})");
        }
        catch
        {
            // Swallow â€” JS interop failures should not crash the component
        }
    }

    // â”€â”€ Guess-mode actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    private void ActivateGuessMode()
    {
        _guessModeActive = true;
        _pendingGuessIds.Clear();
    }

    private void CancelGuessMode()
    {
        _guessModeActive = false;
        _pendingGuessIds.Clear();
    }

    /// <summary>Adds a character to the pending guess list (max 2).</summary>
    private void SelectForGuess(int characterId)
    {
        if (_pendingGuessIds.Count < 2 && !_pendingGuessIds.Contains(characterId))
            _pendingGuessIds.Add(characterId);
    }

    /// <summary>Removes a character from the pending guess list.</summary>
    private void DeselectGuess(int characterId) =>
        _pendingGuessIds.Remove(characterId);

    /// <summary>
    /// Submits the confirmed two-person guess to the server.
    /// On return the phase becomes RoundEnd and StateChanged fires for both players.
    /// </summary>
    private void ConfirmGuess()
    {
        if (!_guessModeActive || _pendingGuessIds.Count != 2 || MyToken is null) return;
        GameSessionService.MakeGuess(Code, MyToken, _pendingGuessIds[0], _pendingGuessIds[1]);
        _guessModeActive = false;
        _pendingGuessIds.Clear();
    }

    // â”€â”€ Post-round actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /// <summary>
    /// Records this player's post-round decision. Both players must choose the same
    /// option before it takes effect; a 60-second server-side timeout defaults to EndGame.
    /// </summary>
    private void MakeDecision(PostRoundDecision decision)
    {
        if (MyToken is not null)
            GameSessionService.MakePostRoundDecision(Code, MyToken, decision);
    }

    // â”€â”€ Chat log presentation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /// <summary>
    /// Annotates each chat message with its question-turn number (1-based for Question messages).
    /// Computed once per render pass â€” avoids stateful counters in Razor markup.
    /// </summary>
    private IReadOnlyList<ChatEntry> GetChatEntries()
    {
        var log = _session?.ChatLog;
        if (log is null || log.Count == 0) return [];

        var result = new List<ChatEntry>(log.Count);
        var turnQ = 0;
        foreach (var msg in log)
        {
            if (msg.Kind == ChatMessageKind.Question) turnQ++;
            result.Add(new ChatEntry(msg, turnQ));
        }
        return result;
    }

    /// <summary>A chat message paired with its computed turn number for rendering.</summary>
    private sealed record ChatEntry(ChatMessage Message, int TurnNumber);

    // â”€â”€ Mystery People selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /// <summary>
    /// Toggles a character in the pending-selection list.
    /// If already selected, deselects it. If not selected and fewer than 2 are chosen, adds it.
    /// </summary>
    private void TogglePending(int characterId)
    {
        if (_pendingIds.Contains(characterId))
            _pendingIds.Remove(characterId);
        else if (_pendingIds.Count < 2)
            _pendingIds.Add(characterId);
    }

    private void ClearPending() => _pendingIds.Clear();

    private void ConfirmSelection()
    {
        if (_pendingIds.Count == 2 && MyToken is not null)
            GameSessionService.SelectMysteryPeople(Code, MyToken, _pendingIds[0], _pendingIds[1]);
    }

    public void Dispose()
    {
        _countdownTimer?.Dispose();
        if (_session is not null)
            _session.StateChanged -= OnSessionStateChanged;
    }
}
