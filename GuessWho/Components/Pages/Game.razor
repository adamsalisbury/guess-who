@page "/game/{Code}"
@rendermode InteractiveServer
@implements IDisposable
@inject GameSessionService GameSessionService
@inject NavigationManager Nav
@inject IJSRuntime JS
@using GuessWho.Data
@using GuessWho.Models

<PageTitle>@Code | Guess Who?</PageTitle>

@* â”€â”€ Session / participant guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
@if (_session is null)
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>Session not found. <a href="/">Return home</a></p>
        </div>
    </div>
}
else if (_me is null)
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>You are not part of this session. <a href="/">Return home</a></p>
        </div>
    </div>
}

@* â”€â”€ CharacterSelection: picker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
else if (_session.Phase == GamePhase.CharacterSelection && !_me.MysteryPersonId.HasValue)
{
    <div class="selection-page">

        <div class="selection-header">
            <h1 class="selection-title">Choose Your Mystery Person</h1>
            <p class="selection-subtitle">
                Your choice is secret â€”
                <strong>@(_opponent?.Name ?? "your opponent")</strong>
                won't know who you picked.
            </p>
        </div>

        <div class="selection-grid-area">
            <div class="selection-grid">
                @foreach (var character in CharacterData.All)
                {
                    var charId = character.Id;
                    <div class="selection-card-wrap @(_pendingId.HasValue && _pendingId != charId ? "selection-card-wrap--dimmed" : "")">
                        <FaceCard Character="character"
                                  Size="md"
                                  ShowName="true"
                                  IsMystery="@(_pendingId == charId)"
                                  OnClick="@(_ => SetPending(charId))" />
                    </div>
                }
            </div>
        </div>

        <div class="selection-footer">
            @if (_pendingId.HasValue)
            {
                var chosen = CharacterData.GetById(_pendingId.Value)!;
                <div class="selection-chosen">
                    <FaceCard Character="chosen" Size="sm" IsMystery="true" ShowName="false" />
                    <span class="selection-chosen-name">@chosen.Name</span>
                </div>
                <button class="btn btn-primary selection-confirm-btn" @onclick="ConfirmSelection">
                    Confirm â€” @chosen.Name is my Mystery Person
                </button>
                <button class="btn btn-secondary" @onclick="ClearPending">
                    Change
                </button>
            }
            else
            {
                <p class="selection-hint">Click any character card to select your Mystery Person</p>
            }
        </div>

    </div>
}

@* â”€â”€ CharacterSelection: waiting for opponent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
else if (_session.Phase == GamePhase.CharacterSelection && _me.MysteryPersonId.HasValue)
{
    var myPerson = CharacterData.GetById(_me.MysteryPersonId.Value);
    <div class="waiting-page">
        <div class="waiting-card">
            <div class="waiting-mystery">
                <FaceCard Character="myPerson" Size="lg" IsMystery="true" ShowName="true" />
            </div>
            <h2 class="waiting-title">Locked In!</h2>
            <p class="waiting-subtitle">
                Your Mystery Person is
                <strong class="waiting-highlight">@myPerson?.Name</strong>.
            </p>
            <p class="waiting-subtitle">
                Waiting for <strong>@(_opponent?.Name ?? "your opponent")</strong> to chooseâ€¦
            </p>
            <div class="spinner waiting-spinner"></div>
        </div>
    </div>
}

@* â”€â”€ Playing / RoundEnd phase â€” full game board (+ overlay) â”€â”€ *@
else if (_session.Phase is GamePhase.Playing or GamePhase.RoundEnd)
{
    var myPerson = CharacterData.GetById(_me!.MysteryPersonId ?? 0);

    <div class="game-board">

        @* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LEFT COLUMN â€” opponent board (top) + own board (bottom)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *@
        <div class="game-left">

            @* â”€â”€ Opponent's board (top, sm cards) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            @* In guess mode the active player can click face-up cards to make a guess *@
            <div class="board-section">
                <div class="board-header">
                    <span class="board-label">
                        @(_opponent?.Name ?? "Opponent")'s Board
                        @if (_guessModeActive)
                        {
                            <span style="color:var(--accent-blue);margin-left:6px;font-size:0.68rem;">
                                â€” GUESS MODE
                            </span>
                        }
                    </span>
                    <span class="board-count">
                        @if (_opponent?.EliminatedIds.Count > 0)
                        {
                            @($"{_opponent.EliminatedIds.Count} eliminated")
                        }
                        else
                        {
                            @("24 remaining")
                        }
                    </span>
                </div>
                <div class="board-grid-area">
                    <div class="board-grid board-grid--sm">
                        @foreach (var charId in _opponent?.BoardOrder ?? [])
                        {
                            var localId = charId;
                            var ch = CharacterData.GetById(localId);
                            var isOppEliminated = _opponent!.EliminatedIds.Contains(localId);
                            // Cards can be guessed only when: guess mode active, it's my turn, not face-down
                            var canGuess = _guessModeActive && _isMyTurn && !isOppEliminated;
                            <FaceCard Character="ch"
                                      Size="sm"
                                      ShowName="true"
                                      FaceDown="@isOppEliminated"
                                      IsGuessable="@canGuess"
                                      OnClick="@GetGuessCallback(localId, canGuess)" />
                        }
                    </div>
                </div>
            </div>

            <div class="board-divider"></div>

            @* â”€â”€ Own board (bottom, md cards) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            <div class="board-section board-section--own">
                <div class="board-header">
                    <span class="board-label">@_me!.Name's Board</span>
                    <span class="board-count">
                        @(_me!.EliminatedIds.Count == 0
                            ? "24 remaining"
                            : $"{_me!.BoardOrder.Count - _me!.EliminatedIds.Count} remaining Â· {_me!.EliminatedIds.Count} eliminated")
                    </span>
                </div>
                <div class="board-grid-area">
                    <div class="board-grid board-grid--md">
                        @foreach (var charId in _me!.BoardOrder)
                        {
                            var localId = charId;
                            var ch = CharacterData.GetById(localId);
                            var isMystery = localId == _me!.MysteryPersonId;
                            var isEliminated = _me!.EliminatedIds.Contains(localId);
                            var canEliminate = _isMyTurn && !isMystery && !isEliminated;
                            <FaceCard Character="ch"
                                      Size="md"
                                      ShowName="true"
                                      IsMystery="@isMystery"
                                      FaceDown="@isEliminated"
                                      IsEliminatable="@canEliminate"
                                      OnClick="@GetEliminateCallback(localId, canEliminate)" />
                        }
                    </div>
                </div>
            </div>

        </div>

        @* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RIGHT COLUMN â€” score bar, mystery person, chat panel
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *@
        <div class="game-right">

            @* â”€â”€ Score & status bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            <div class="score-bar">
                <div class="score-round">Round @_session.RoundNumber</div>
                <div class="score-display">
                    <span class="score-name">@_session.Player1?.Name</span>
                    <span class="score-value">@_session.Player1?.RoundWins</span>
                    <span class="score-dash">â€“</span>
                    <span class="score-value">@_session.Player2?.RoundWins</span>
                    <span class="score-name score-name--right">@_session.Player2?.Name</span>
                </div>
                <div class="turn-status @(_isMyTurn ? "turn-status--active" : "turn-status--waiting")">
                    @if (_isMyTurn)
                    {
                        <span class="turn-indicator-dot"></span>
                        <span>Your turn, @(_me?.Name ?? "you")</span>
                    }
                    else
                    {
                        <span>Waiting for @(_opponent?.Name ?? "opponent")â€¦</span>
                    }
                </div>
                @if (_session.CountdownActive)
                {
                    <div class="countdown-bar">
                        <span class="countdown-icon">â±</span>
                        <span class="countdown-text">Turn ending in <strong>@CountdownRemaining</strong>sâ€¦</span>
                    </div>
                }
            </div>

            @* â”€â”€ Mystery Person display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            <div class="mystery-panel">
                <div class="mystery-label">Your Mystery Person</div>
                @if (myPerson is not null)
                {
                    <div class="mystery-card-wrap">
                        <FaceCard Character="myPerson" Size="lg" IsMystery="true" ShowName="true" />
                    </div>
                }
                <div class="mystery-keep-secret">Keep this secret from your opponent!</div>
            </div>

            @* â”€â”€ Chat panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
            <div class="chat-panel">
                <div class="chat-header">Chat</div>

                @* â”€â”€ Message log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                <div class="chat-log" @ref="_chatLogRef">
                    @if (_session!.ChatLog.Count == 0)
                    {
                        <p class="chat-placeholder">The game is afootâ€¦</p>
                    }
                    else
                    {
                        @foreach (var msg in _session.ChatLog)
                        {
                            var kindClass = msg.Kind.ToString().ToLowerInvariant();
                            <div class="chat-msg chat-msg--@kindClass">
                                <span class="chat-msg-sender">@msg.SenderName</span>
                                <span class="chat-msg-text">@msg.Text</span>
                            </div>
                        }
                    }
                </div>

                @* â”€â”€ Input area â€” branches on turn state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                <div class="chat-input-area">

                    @* End Turn always available to active player (even in guess mode) *@
                    @if (_isMyTurn)
                    {
                        <button class="btn btn-secondary end-turn-btn" @onclick="EndTurn">
                            End Turn
                        </button>
                    }

                    @* â”€â”€ Active player: no question asked yet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                    @if (_isMyTurn && !_session.QuestionAsked)
                    {
                        @if (_guessModeActive)
                        {
                            @* Guess mode active â€” confirmation or hint *@
                            @if (_pendingGuessId.HasValue)
                            {
                                @* Player has clicked a card â€” show confirmation *@
                                var pendingChar = CharacterData.GetById(_pendingGuessId.Value);
                                <div class="guess-confirm-panel">
                                    <div class="guess-confirm-name">@pendingChar?.Name</div>
                                    <div class="guess-confirm-warning">
                                        Guess this person? A wrong guess means you lose the round immediately.
                                    </div>
                                    <div class="guess-confirm-buttons">
                                        <button class="btn-guess-confirm" @onclick="ConfirmGuess">Confirm Guess</button>
                                        <button class="btn-guess-cancel"  @onclick="CancelGuessMode">Cancel</button>
                                    </div>
                                </div>
                            }
                            else
                            {
                                @* No pending card yet â€” show instruction + cancel *@
                                <div class="guess-mode-active">
                                    <p class="guess-mode-hint">ğŸ¯ Click a face on the opponent's board to guess</p>
                                    <button class="btn-guess-cancel" @onclick="CancelGuessMode">Cancel Guess Mode</button>
                                </div>
                            }
                        }
                        else
                        {
                            @* Normal state â€” question input + Make a Guess button *@
                            <div class="chat-input-row">
                                <input class="text-input chat-input"
                                       type="text"
                                       placeholder="Ask a yes/no questionâ€¦"
                                       @bind="_chatInput"
                                       @bind:event="oninput"
                                       @onkeydown="OnChatKeyDown"
                                       maxlength="200" />
                                <button class="btn btn-primary chat-send-btn"
                                        disabled="@(string.IsNullOrWhiteSpace(_chatInput))"
                                        @onclick="SendQuestion">
                                    Send
                                </button>
                            </div>
                            <button class="guess-mode-btn" @onclick="ActivateGuessMode">
                                ğŸ¯ Make a Guess Instead
                            </button>
                        }
                    }

                    @* â”€â”€ Active player: question already asked â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
                    else if (_isMyTurn && _session.QuestionAsked)
                    {
                        @if (_session.AwaitingAnswer)
                        {
                            <p class="chat-awaiting">Waiting for @(_opponent?.Name ?? "opponent") to answerâ€¦</p>
                        }
                        else if (_session.CountdownActive)
                        {
                            <p class="chat-awaiting">
                                Turn ends in <strong class="countdown-inline">@CountdownRemaining</strong>s â€” or end it now.
                            </p>
                        }
                        else
                        {
                            <p class="chat-awaiting">Question answered â€” end your turn when ready.</p>
                        }
                    }

                    @* â”€â”€ Inactive player: question awaiting answer â”€â”€â”€â”€â”€â”€ *@
                    else if (!_isMyTurn && _session.AwaitingAnswer)
                    {
                        <div class="chat-yn-row">
                            <p class="chat-yn-prompt">Answer @(_session.GetPlayer(_session.ActivePlayerToken)?.Name ?? "opponent")'s question:</p>
                            <div class="chat-yn-buttons">
                                <button class="btn btn-yes" @onclick="@(() => RespondToQuestion(true))">Yes</button>
                                <button class="btn btn-no"  @onclick="@(() => RespondToQuestion(false))">No</button>
                            </div>
                        </div>
                    }

                    @* â”€â”€ Inactive player: nothing to do â€” locked â”€â”€â”€â”€â”€â”€â”€â”€ *@
                    else
                    {
                        <div class="chat-input-row">
                            <input class="text-input chat-input"
                                   type="text"
                                   placeholder="Waiting for your turnâ€¦"
                                   disabled="true" />
                            <button class="btn btn-primary chat-send-btn" disabled="true">Send</button>
                        </div>
                    }

                </div>
            </div>

        </div>
    </div>

    @* â”€â”€ Round-End Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
    @* Rendered on top of the board when the phase is RoundEnd.  *@
    @if (_session.Phase == GamePhase.RoundEnd)
    {
        var isWinner   = _session.RoundWinnerToken == MyToken;
        var winnerName = _session.GetPlayer(_session.RoundWinnerToken ?? "")?.Name ?? "Unknown";
        var loserName  = _session.GetOpponent(_session.RoundWinnerToken ?? "")?.Name ?? "Unknown";

        var p1Person = _session.Player1?.MysteryPersonId.HasValue == true
            ? CharacterData.GetById(_session.Player1.MysteryPersonId.Value) : null;
        var p2Person = _session.Player2?.MysteryPersonId.HasValue == true
            ? CharacterData.GetById(_session.Player2.MysteryPersonId.Value) : null;

        <div class="round-end-overlay">
            <div class="round-end-card">

                @* Outcome heading *@
                <div class="round-end-outcome @(isWinner ? "round-end-outcome--win" : "round-end-outcome--loss")">
                    @if (isWinner)
                    {
                        @("You win the round! ğŸ‰")
                    }
                    else
                    {
                        @("You lose the round")
                    }
                </div>

                @* Explanation *@
                <p class="round-end-subtext">
                    @if (_session.EndReason == RoundEndReason.CorrectGuess)
                    {
                        @($"{winnerName} guessed correctly!")
                    }
                    else
                    {
                        @($"{loserName} guessed wrong â€” {winnerName} wins!")
                    }
                </p>

                <div class="round-end-divider"></div>

                @* Reveal both Mystery People *@
                <div class="round-end-reveal">
                    @if (p1Person is not null)
                    {
                        <div class="round-end-reveal-slot">
                            <div class="round-end-reveal-label">@(_session.Player1?.Name)'s Person</div>
                            <FaceCard Character="p1Person" Size="md" ShowName="false" IsMystery="true" />
                            <div class="round-end-reveal-name">@p1Person.Name</div>
                        </div>
                    }
                    @if (p2Person is not null)
                    {
                        <div class="round-end-reveal-slot">
                            <div class="round-end-reveal-label">@(_session.Player2?.Name)'s Person</div>
                            <FaceCard Character="p2Person" Size="md" ShowName="false" IsMystery="true" />
                            <div class="round-end-reveal-name">@p2Person.Name</div>
                        </div>
                    }
                </div>

                <div class="round-end-divider"></div>

                @* Championship score *@
                <div class="round-end-score">
                    <span class="round-end-score-name">@_session.Player1?.Name</span>
                    <span class="round-end-score-value">@_session.Player1?.RoundWins</span>
                    <span class="round-end-score-dash">â€“</span>
                    <span class="round-end-score-value">@_session.Player2?.RoundWins</span>
                    <span class="round-end-score-name round-end-score-name--right">@_session.Player2?.Name</span>
                </div>

                @* Action buttons *@
                <div class="round-end-actions">
                    <button class="btn btn-primary" @onclick="NewRound">New Round</button>
                    <button class="btn btn-secondary" @onclick="LeaveGame">End Game</button>
                </div>

            </div>
        </div>
    }
}

@* â”€â”€ Fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *@
else
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>Session ended or unavailable. <a href="/">Return home</a></p>
        </div>
    </div>
}

@code {
    [Parameter] public string Code { get; set; } = "";
    [SupplyParameterFromQuery(Name = "name")] public string? PlayerName { get; set; }
    [SupplyParameterFromQuery(Name = "token")] public string? MyToken { get; set; }

    private GameSession? _session;
    private PlayerState? _me;
    private PlayerState? _opponent;

    /// <summary>Card the player has clicked but not yet confirmed (Mystery Person selection).</summary>
    private int? _pendingId;

    /// <summary>True when the active player has activated guess mode on the opponent's board.</summary>
    private bool _guessModeActive;

    /// <summary>Character ID the active player has clicked in guess mode, awaiting confirmation.</summary>
    private int? _pendingGuessId;

    /// <summary>Current value of the chat text input.</summary>
    private string _chatInput = "";

    /// <summary>Reference to the chat log div, used for auto-scroll.</summary>
    private ElementReference _chatLogRef;

    /// <summary>Timer that drives the post-answer countdown display and automatic turn-end.</summary>
    private System.Threading.Timer? _countdownTimer;

    /// <summary>Mirror of GameSession.CountdownSeconds â€” used for client-side remaining-time math.</summary>
    private const int CountdownSeconds = GameSession.CountdownSeconds;

    /// <summary>True when it is this player's turn to act.</summary>
    private bool _isMyTurn =>
        _session is not null && MyToken is not null && _session.IsActivePlayer(MyToken);

    /// <summary>
    /// Remaining whole seconds in the current countdown, clamped to [0, CountdownSeconds].
    /// Returns 0 when no countdown is active.
    /// </summary>
    private int CountdownRemaining =>
        _session?.CountdownActive == true
            ? (int)Math.Ceiling(Math.Max(0,
                CountdownSeconds - (DateTime.UtcNow - _session.CountdownStartedAt!.Value).TotalSeconds))
            : 0;

    protected override void OnInitialized()
    {
        _session = GameSessionService.GetSession(Code);
        if (_session is null) return;

        _me       = _session.GetPlayer(MyToken ?? "");
        _opponent = _session.GetOpponent(MyToken ?? "");

        _session.StateChanged += OnSessionStateChanged;
    }

    /// <summary>
    /// Invoked on a thread-pool thread when session state changes.
    /// Marshals the UI update back to this component's Blazor circuit thread.
    /// </summary>
    private async void OnSessionStateChanged(object? sender, EventArgs e)
    {
        await InvokeAsync(async () =>
        {
            _opponent = _session?.GetOpponent(MyToken ?? "");

            // Clear guess mode when the turn passes to the opponent or the round ends
            if (!_isMyTurn || _session?.Phase != GamePhase.Playing)
            {
                _guessModeActive = false;
                _pendingGuessId  = null;
            }

            StateHasChanged();

            // Navigate home immediately when the session enters GameEnd phase
            if (_session?.Phase == GamePhase.GameEnd)
            {
                Nav.NavigateTo("/");
                return;
            }

            // Start the countdown timer when the session enters the post-answer countdown window.
            // No-ops if the timer is already running (CountdownActive was already true last render).
            if (_session?.CountdownActive == true)
                StartCountdownTimer();

            // Auto-scroll chat log when new messages arrive
            if (_session?.Phase is GamePhase.Playing or GamePhase.RoundEnd)
                await ScrollChatToBottom();
        });
    }

    /// <summary>
    /// Creates (or re-creates) a 500ms-interval timer that drives the countdown display and
    /// fires StartNextTurn when the countdown expires.
    /// Only the active player's circuit calls StartNextTurn; both circuits update the display.
    /// </summary>
    private void StartCountdownTimer()
    {
        // Dispose any existing timer before creating a new one
        _countdownTimer?.Dispose();
        _countdownTimer = new System.Threading.Timer(async _ =>
        {
            try
            {
                if (_session?.CountdownActive != true)
                {
                    // Countdown ended â€” dispose the timer and trigger a final render
                    _countdownTimer?.Dispose();
                    _countdownTimer = null;
                    await InvokeAsync(StateHasChanged);
                    return;
                }

                var elapsed = (DateTime.UtcNow - _session.CountdownStartedAt!.Value).TotalSeconds;

                // Only the active player fires StartNextTurn to avoid double-fire from both circuits
                if (elapsed >= CountdownSeconds && _isMyTurn)
                    GameSessionService.StartNextTurn(Code, MyToken!);

                await InvokeAsync(StateHasChanged);
            }
            catch (ObjectDisposedException) { /* Component was disposed â€” stop silently */ }
            catch (Exception) { /* Swallow any other interop failures */ }
        }, null, dueTime: 0, period: 500);
    }

    /// <summary>
    /// Returns an EventCallback that calls EliminateCard when canEliminate is true,
    /// or an empty callback otherwise. Avoids ambiguous ternary-lambda type inference.
    /// </summary>
    private EventCallback<Character?> GetEliminateCallback(int characterId, bool canEliminate) =>
        canEliminate
            ? EventCallback.Factory.Create<Character?>(this, _ => EliminateCard(characterId))
            : default;

    /// <summary>
    /// Returns an EventCallback that calls SetPendingGuess when canGuess is true,
    /// or an empty callback otherwise.
    /// </summary>
    private EventCallback<Character?> GetGuessCallback(int characterId, bool canGuess) =>
        canGuess
            ? EventCallback.Factory.Create<Character?>(this, _ => SetPendingGuess(characterId))
            : default;

    /// <summary>
    /// Eliminates a character from the active player's own board.
    /// Server-side guards prevent eliminating the Mystery Person or non-active-player requests.
    /// </summary>
    private void EliminateCard(int characterId)
    {
        if (!_isMyTurn || MyToken is null) return;
        GameSessionService.EliminateCharacter(Code, MyToken, characterId);
    }

    /// <summary>Passes the turn to the opposing player.</summary>
    private void EndTurn()
    {
        if (MyToken is not null)
            GameSessionService.StartNextTurn(Code, MyToken);
    }

    /// <summary>Sends the current chat input as a question. Called by the Send button or Enter key.</summary>
    private async Task SendQuestion()
    {
        if (!_isMyTurn || string.IsNullOrWhiteSpace(_chatInput)) return;
        GameSessionService.AskQuestion(Code, MyToken!, _chatInput.Trim());
        _chatInput = "";
        await ScrollChatToBottom();
    }

    /// <summary>Called when the inactive player clicks Yes or No to answer the pending question.</summary>
    private async Task RespondToQuestion(bool yes)
    {
        if (_isMyTurn || _session?.AwaitingAnswer != true) return;
        GameSessionService.AnswerQuestion(Code, MyToken!, yes);
        await ScrollChatToBottom();
    }

    /// <summary>Handles Enter-key press in the chat input to submit the question.</summary>
    private async Task OnChatKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await SendQuestion();
    }

    /// <summary>Scrolls the chat log to the bottom after a new message is added.</summary>
    private async Task ScrollChatToBottom()
    {
        try
        {
            await JS.InvokeVoidAsync("eval",
                "document.querySelector('.chat-log')?.scrollTo({top:999999,behavior:'smooth'})");
        }
        catch
        {
            // Swallow â€” JS interop failures should not crash the component
        }
    }

    // â”€â”€ Guess-mode actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    private void ActivateGuessMode()
    {
        _guessModeActive = true;
        _pendingGuessId  = null;
    }

    private void CancelGuessMode()
    {
        _guessModeActive = false;
        _pendingGuessId  = null;
    }

    private void SetPendingGuess(int characterId) => _pendingGuessId = characterId;

    /// <summary>
    /// Submits the confirmed guess to the server. On return the phase will become RoundEnd
    /// and StateChanged fires, triggering the overlay for both players.
    /// </summary>
    private void ConfirmGuess()
    {
        if (!_guessModeActive || !_pendingGuessId.HasValue || MyToken is null) return;
        GameSessionService.MakeGuess(Code, MyToken, _pendingGuessId.Value);
        _guessModeActive = false;
        _pendingGuessId  = null;
    }

    // â”€â”€ Post-round actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /// <summary>Starts a new round within the same session. Resets per-round state for both players.</summary>
    private void NewRound()
    {
        if (MyToken is not null)
            GameSessionService.StartNewRound(Code, MyToken);
    }

    /// <summary>Ends the game session; both players are navigated home via GameEnd phase.</summary>
    private void LeaveGame()
    {
        if (MyToken is not null)
            GameSessionService.EndGame(Code, MyToken);
        else
            Nav.NavigateTo("/");
    }

    // â”€â”€ Mystery Person selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    private void SetPending(int characterId) => _pendingId = characterId;

    private void ClearPending() => _pendingId = null;

    private void ConfirmSelection()
    {
        if (_pendingId.HasValue && MyToken is not null)
            GameSessionService.SelectMysteryPerson(Code, MyToken, _pendingId.Value);
    }

    public void Dispose()
    {
        _countdownTimer?.Dispose();
        if (_session is not null)
            _session.StateChanged -= OnSessionStateChanged;
    }
}
