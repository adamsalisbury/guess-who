@page "/game/{Code}"
@rendermode InteractiveServer
@implements IDisposable
@inject GameSessionService GameSessionService
@inject NavigationManager Nav
@inject IJSRuntime JS
@using GuessWho.Data
@using GuessWho.Models

<PageTitle>@Code | Guess Who?</PageTitle>

@* ── Session / participant guard ────────────────────────────── *@
@if (_session is null)
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>Session not found. <a href="/">Return home</a></p>
        </div>
    </div>
}
else if (_me is null)
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>You are not part of this session. <a href="/">Return home</a></p>
        </div>
    </div>
}

@* ── CharacterSelection: picker ─────────────────────────────── *@
else if (_session.Phase == GamePhase.CharacterSelection && !_me.MysteryPersonId.HasValue)
{
    <div class="selection-page">

        <div class="selection-header">
            <h1 class="selection-title">Choose Your Mystery Person</h1>
            <p class="selection-subtitle">
                Your choice is secret —
                <strong>@(_opponent?.Name ?? "your opponent")</strong>
                won't know who you picked.
            </p>
        </div>

        <div class="selection-grid-area">
            <div class="selection-grid">
                @foreach (var character in CharacterData.All)
                {
                    var charId = character.Id;
                    <div class="selection-card-wrap @(_pendingId.HasValue && _pendingId != charId ? "selection-card-wrap--dimmed" : "")">
                        <FaceCard Character="character"
                                  Size="md"
                                  ShowName="true"
                                  IsMystery="@(_pendingId == charId)"
                                  OnClick="@(_ => SetPending(charId))" />
                    </div>
                }
            </div>
        </div>

        <div class="selection-footer">
            @if (_pendingId.HasValue)
            {
                var chosen = CharacterData.GetById(_pendingId.Value)!;
                <div class="selection-chosen">
                    <FaceCard Character="chosen" Size="sm" IsMystery="true" ShowName="false" />
                    <span class="selection-chosen-name">@chosen.Name</span>
                </div>
                <button class="btn btn-primary selection-confirm-btn" @onclick="ConfirmSelection">
                    Confirm — @chosen.Name is my Mystery Person
                </button>
                <button class="btn btn-secondary" @onclick="ClearPending">
                    Change
                </button>
            }
            else
            {
                <p class="selection-hint">Click any character card to select your Mystery Person</p>
            }
        </div>

    </div>
}

@* ── CharacterSelection: waiting for opponent ──────────────── *@
else if (_session.Phase == GamePhase.CharacterSelection && _me.MysteryPersonId.HasValue)
{
    var myPerson = CharacterData.GetById(_me.MysteryPersonId.Value);
    <div class="waiting-page">
        <div class="waiting-card">
            <div class="waiting-mystery">
                <FaceCard Character="myPerson" Size="lg" IsMystery="true" ShowName="true" />
            </div>
            <h2 class="waiting-title">Locked In!</h2>
            <p class="waiting-subtitle">
                Your Mystery Person is
                <strong class="waiting-highlight">@myPerson?.Name</strong>.
            </p>
            <p class="waiting-subtitle">
                Waiting for <strong>@(_opponent?.Name ?? "your opponent")</strong> to choose…
            </p>
            <div class="spinner waiting-spinner"></div>
        </div>
    </div>
}

@* ── Playing phase — full game board ───────────────────────── *@
else if (_session.Phase == GamePhase.Playing)
{
    var myPerson = CharacterData.GetById(_me!.MysteryPersonId ?? 0);

    <div class="game-board">

        @* ════════════════════════════════════════════════════════
           LEFT COLUMN — opponent board (top) + own board (bottom)
           ════════════════════════════════════════════════════════ *@
        <div class="game-left">

            @* ── Opponent's board (top, sm cards, read-only) ─────── *@
            <div class="board-section">
                <div class="board-header">
                    <span class="board-label">@(_opponent?.Name ?? "Opponent")'s Board</span>
                    <span class="board-count">
                        @if (_opponent?.EliminatedIds.Count > 0)
                        {
                            @($"{_opponent.EliminatedIds.Count} eliminated")
                        }
                        else
                        {
                            @("24 remaining")
                        }
                    </span>
                </div>
                <div class="board-grid-area">
                    <div class="board-grid board-grid--sm">
                        @foreach (var charId in _opponent?.BoardOrder ?? [])
                        {
                            var localId = charId;
                            var ch = CharacterData.GetById(localId);
                            <FaceCard Character="ch"
                                      Size="sm"
                                      ShowName="true"
                                      FaceDown="@(_opponent!.EliminatedIds.Contains(localId))" />
                        }
                    </div>
                </div>
            </div>

            <div class="board-divider"></div>

            @* ── Own board (bottom, md cards) ────────────────────── *@
            <div class="board-section board-section--own">
                <div class="board-header">
                    <span class="board-label">@_me!.Name's Board</span>
                    <span class="board-count">
                        @(_me!.EliminatedIds.Count == 0
                            ? "24 remaining"
                            : $"{_me!.BoardOrder.Count - _me!.EliminatedIds.Count} remaining · {_me!.EliminatedIds.Count} eliminated")
                    </span>
                </div>
                <div class="board-grid-area">
                    <div class="board-grid board-grid--md">
                        @foreach (var charId in _me!.BoardOrder)
                        {
                            var localId = charId;
                            var ch = CharacterData.GetById(localId);
                            var isMystery = localId == _me!.MysteryPersonId;
                            var isEliminated = _me!.EliminatedIds.Contains(localId);
                            var canEliminate = _isMyTurn && !isMystery && !isEliminated;
                            <FaceCard Character="ch"
                                      Size="md"
                                      ShowName="true"
                                      IsMystery="@isMystery"
                                      FaceDown="@isEliminated"
                                      IsEliminatable="@canEliminate"
                                      OnClick="@GetEliminateCallback(localId, canEliminate)" />
                        }
                    </div>
                </div>
            </div>

        </div>

        @* ════════════════════════════════════════════════════════
           RIGHT COLUMN — score bar, mystery person, chat panel
           ════════════════════════════════════════════════════════ *@
        <div class="game-right">

            @* ── Score & status bar ──────────────────────────────── *@
            <div class="score-bar">
                <div class="score-round">Round @_session.RoundNumber</div>
                <div class="score-display">
                    <span class="score-name">@_session.Player1?.Name</span>
                    <span class="score-value">@_session.Player1?.RoundWins</span>
                    <span class="score-dash">–</span>
                    <span class="score-value">@_session.Player2?.RoundWins</span>
                    <span class="score-name score-name--right">@_session.Player2?.Name</span>
                </div>
                <div class="turn-status @(_isMyTurn ? "turn-status--active" : "turn-status--waiting")">
                    @if (_isMyTurn)
                    {
                        <span class="turn-indicator-dot"></span>
                        <span>Your turn, @(_me?.Name ?? "you")</span>
                    }
                    else
                    {
                        <span>Waiting for @(_opponent?.Name ?? "opponent")…</span>
                    }
                </div>
                @if (_session.CountdownActive)
                {
                    <div class="countdown-bar">
                        <span class="countdown-icon">⏱</span>
                        <span class="countdown-text">Turn ending in <strong>@CountdownRemaining</strong>s…</span>
                    </div>
                }
            </div>

            @* ── Mystery Person display ──────────────────────────── *@
            <div class="mystery-panel">
                <div class="mystery-label">Your Mystery Person</div>
                @if (myPerson is not null)
                {
                    <div class="mystery-card-wrap">
                        <FaceCard Character="myPerson" Size="lg" IsMystery="true" ShowName="true" />
                    </div>
                }
                <div class="mystery-keep-secret">Keep this secret from your opponent!</div>
            </div>

            @* ── Chat panel ──────────────────────────────────────── *@
            <div class="chat-panel">
                <div class="chat-header">Chat</div>

                @* ── Message log ─────────────────────────────────── *@
                <div class="chat-log" @ref="_chatLogRef">
                    @if (_session!.ChatLog.Count == 0)
                    {
                        <p class="chat-placeholder">The game is afoot…</p>
                    }
                    else
                    {
                        @foreach (var msg in _session.ChatLog)
                        {
                            var kindClass = msg.Kind.ToString().ToLowerInvariant();
                            <div class="chat-msg chat-msg--@kindClass">
                                <span class="chat-msg-sender">@msg.SenderName</span>
                                <span class="chat-msg-text">@msg.Text</span>
                            </div>
                        }
                    }
                </div>

                @* ── Input area — branches on turn state ─────────── *@
                <div class="chat-input-area">

                    @* End Turn always available to active player *@
                    @if (_isMyTurn)
                    {
                        <button class="btn btn-secondary end-turn-btn" @onclick="EndTurn">
                            End Turn
                        </button>
                    }

                    @* State 1: Active player, no question asked yet — show text input *@
                    @if (_isMyTurn && !_session.QuestionAsked)
                    {
                        <div class="chat-input-row">
                            <input class="text-input chat-input"
                                   type="text"
                                   placeholder="Ask a yes/no question…"
                                   @bind="_chatInput"
                                   @bind:event="oninput"
                                   @onkeydown="OnChatKeyDown"
                                   maxlength="200" />
                            <button class="btn btn-primary chat-send-btn"
                                    disabled="@(string.IsNullOrWhiteSpace(_chatInput))"
                                    @onclick="SendQuestion">
                                Send
                            </button>
                        </div>
                    }

                    @* State 2: Active player, question asked — show lock message *@
                    else if (_isMyTurn && _session.QuestionAsked)
                    {
                        @if (_session.AwaitingAnswer)
                        {
                            <p class="chat-awaiting">Waiting for @(_opponent?.Name ?? "opponent") to answer…</p>
                        }
                        else if (_session.CountdownActive)
                        {
                            <p class="chat-awaiting">
                                Turn ends in <strong class="countdown-inline">@CountdownRemaining</strong>s — or end it now.
                            </p>
                        }
                        else
                        {
                            <p class="chat-awaiting">Question answered — end your turn when ready.</p>
                        }
                    }

                    @* State 3: Inactive player, question awaiting answer — show Yes/No *@
                    else if (!_isMyTurn && _session.AwaitingAnswer)
                    {
                        <div class="chat-yn-row">
                            <p class="chat-yn-prompt">Answer @(_session.GetPlayer(_session.ActivePlayerToken)?.Name ?? "opponent")'s question:</p>
                            <div class="chat-yn-buttons">
                                <button class="btn btn-yes" @onclick="@(() => RespondToQuestion(true))">Yes</button>
                                <button class="btn btn-no"  @onclick="@(() => RespondToQuestion(false))">No</button>
                            </div>
                        </div>
                    }

                    @* State 4: Inactive player, nothing to answer — waiting indicator *@
                    else
                    {
                        <div class="chat-input-row">
                            <input class="text-input chat-input"
                                   type="text"
                                   placeholder="Waiting for your turn…"
                                   disabled="true" />
                            <button class="btn btn-primary chat-send-btn" disabled="true">Send</button>
                        </div>
                    }

                </div>
            </div>

        </div>
    </div>
}

@* ── Fallback ──────────────────────────────────────────────── *@
else
{
    <div class="game-placeholder-page">
        <div class="placeholder-card">
            <p>Session ended or unavailable. <a href="/">Return home</a></p>
        </div>
    </div>
}

@code {
    [Parameter] public string Code { get; set; } = "";
    [SupplyParameterFromQuery(Name = "name")] public string? PlayerName { get; set; }
    [SupplyParameterFromQuery(Name = "token")] public string? MyToken { get; set; }

    private GameSession? _session;
    private PlayerState? _me;
    private PlayerState? _opponent;

    /// <summary>Card the player has clicked but not yet confirmed.</summary>
    private int? _pendingId;

    /// <summary>Current value of the chat text input.</summary>
    private string _chatInput = "";

    /// <summary>Reference to the chat log div, used for auto-scroll.</summary>
    private ElementReference _chatLogRef;

    /// <summary>Timer that drives the post-answer countdown display and automatic turn-end.</summary>
    private System.Threading.Timer? _countdownTimer;

    /// <summary>Mirror of GameSession.CountdownSeconds — used for client-side remaining-time math.</summary>
    private const int CountdownSeconds = GameSession.CountdownSeconds;

    /// <summary>True when it is this player's turn to act.</summary>
    private bool _isMyTurn =>
        _session is not null && MyToken is not null && _session.IsActivePlayer(MyToken);

    /// <summary>
    /// Remaining whole seconds in the current countdown, clamped to [0, CountdownSeconds].
    /// Returns 0 when no countdown is active.
    /// </summary>
    private int CountdownRemaining =>
        _session?.CountdownActive == true
            ? (int)Math.Ceiling(Math.Max(0,
                CountdownSeconds - (DateTime.UtcNow - _session.CountdownStartedAt!.Value).TotalSeconds))
            : 0;

    protected override void OnInitialized()
    {
        _session = GameSessionService.GetSession(Code);
        if (_session is null) return;

        _me       = _session.GetPlayer(MyToken ?? "");
        _opponent = _session.GetOpponent(MyToken ?? "");

        _session.StateChanged += OnSessionStateChanged;
    }

    /// <summary>
    /// Invoked on a thread-pool thread when session state changes.
    /// Marshals the UI update back to this component's Blazor circuit thread.
    /// </summary>
    private async void OnSessionStateChanged(object? sender, EventArgs e)
    {
        await InvokeAsync(async () =>
        {
            _opponent = _session?.GetOpponent(MyToken ?? "");
            StateHasChanged();

            // Start the countdown timer when the session enters the post-answer countdown window.
            // No-ops if the timer is already running (CountdownActive was already true last render).
            if (_session?.CountdownActive == true)
                StartCountdownTimer();

            // Auto-scroll chat log when new messages arrive
            if (_session?.Phase == GamePhase.Playing)
                await ScrollChatToBottom();
        });
    }

    /// <summary>
    /// Creates (or re-creates) a 500ms-interval timer that drives the countdown display and
    /// fires StartNextTurn when the countdown expires.
    /// Only the active player's circuit calls StartNextTurn; both circuits update the display.
    /// </summary>
    private void StartCountdownTimer()
    {
        // Dispose any existing timer before creating a new one
        _countdownTimer?.Dispose();
        _countdownTimer = new System.Threading.Timer(async _ =>
        {
            try
            {
                if (_session?.CountdownActive != true)
                {
                    // Countdown ended — dispose the timer and trigger a final render
                    _countdownTimer?.Dispose();
                    _countdownTimer = null;
                    await InvokeAsync(StateHasChanged);
                    return;
                }

                var elapsed = (DateTime.UtcNow - _session.CountdownStartedAt!.Value).TotalSeconds;

                // Only the active player fires StartNextTurn to avoid double-fire from both circuits
                if (elapsed >= CountdownSeconds && _isMyTurn)
                    GameSessionService.StartNextTurn(Code, MyToken!);

                await InvokeAsync(StateHasChanged);
            }
            catch (ObjectDisposedException) { /* Component was disposed — stop silently */ }
            catch (Exception) { /* Swallow any other interop failures */ }
        }, null, dueTime: 0, period: 500);
    }

    /// <summary>
    /// Returns an EventCallback that calls EliminateCard when canEliminate is true,
    /// or an empty callback otherwise. Avoids ambiguous ternary-lambda type inference.
    /// </summary>
    private EventCallback<Character?> GetEliminateCallback(int characterId, bool canEliminate) =>
        canEliminate
            ? EventCallback.Factory.Create<Character?>(this, _ => EliminateCard(characterId))
            : default;

    /// <summary>
    /// Eliminates a character from the active player's own board.
    /// Server-side guards prevent eliminating the Mystery Person or non-active-player requests.
    /// </summary>
    private void EliminateCard(int characterId)
    {
        if (!_isMyTurn || MyToken is null) return;
        GameSessionService.EliminateCharacter(Code, MyToken, characterId);
    }

    /// <summary>Passes the turn to the opposing player.</summary>
    private void EndTurn()
    {
        if (MyToken is not null)
            GameSessionService.StartNextTurn(Code, MyToken);
    }

    /// <summary>Sends the current chat input as a question. Called by the Send button or Enter key.</summary>
    private async Task SendQuestion()
    {
        if (!_isMyTurn || string.IsNullOrWhiteSpace(_chatInput)) return;
        GameSessionService.AskQuestion(Code, MyToken!, _chatInput.Trim());
        _chatInput = "";
        await ScrollChatToBottom();
    }

    /// <summary>Called when the inactive player clicks Yes or No to answer the pending question.</summary>
    private async Task RespondToQuestion(bool yes)
    {
        if (_isMyTurn || _session?.AwaitingAnswer != true) return;
        GameSessionService.AnswerQuestion(Code, MyToken!, yes);
        await ScrollChatToBottom();
    }

    /// <summary>Handles Enter-key press in the chat input to submit the question.</summary>
    private async Task OnChatKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await SendQuestion();
    }

    /// <summary>Scrolls the chat log to the bottom after a new message is added.</summary>
    private async Task ScrollChatToBottom()
    {
        try
        {
            await JS.InvokeVoidAsync("eval",
                "document.querySelector('.chat-log')?.scrollTo({top:999999,behavior:'smooth'})");
        }
        catch
        {
            // Swallow — JS interop failures should not crash the component
        }
    }

    private void SetPending(int characterId) => _pendingId = characterId;

    private void ClearPending() => _pendingId = null;

    private void ConfirmSelection()
    {
        if (_pendingId.HasValue && MyToken is not null)
            GameSessionService.SelectMysteryPerson(Code, MyToken, _pendingId.Value);
    }

    public void Dispose()
    {
        _countdownTimer?.Dispose();
        if (_session is not null)
            _session.StateChanged -= OnSessionStateChanged;
    }
}
